//!
//! The AST module contains all structs and enums for the abstract syntax tree generated by the parser
//!
//! All AST nodes are bump allocated into the lifetime `'ast`  

use crate::errors::Span;
use crate::value::Symbol;
use bumpalo::collections::Vec;

#[derive(Debug, PartialEq, Eq, Hash)]
pub struct Ident {
    pub sym: Symbol,
    pub span: Span,
}

#[derive(Debug, PartialEq)]
pub struct Program<'ast>(pub Vec<'ast, Stmt<'ast>>);

#[derive(Debug, PartialEq)]
pub struct Block<'ast> {
    pub stmts: Vec<'ast, Stmt<'ast>>,
    pub span: Span,
}

#[derive(Debug, PartialEq)]
pub enum Stmt<'ast> {
    Declaration(Declaration<'ast>),
    Assignment(Assignment<'ast>),
    FnDecl(FnDecl<'ast>),
    If(IfStmt<'ast>),
    Loop(Block<'ast>, Span),
    While(WhileStmt<'ast>),
    Break(Span),
    Return(Option<Expr<'ast>>, Span),
    Block(Block<'ast>),
    Expr(Expr<'ast>),
    Print(Expr<'ast>, Span),
}

#[derive(Debug, PartialEq)]
pub struct Declaration<'ast> {
    pub span: Span,
    pub name: Ident,
    pub init: Expr<'ast>,
}

#[derive(Debug, PartialEq)]
pub struct Assignment<'ast> {
    pub span: Span,
    pub lhs: Expr<'ast>,
    pub rhs: Expr<'ast>,
}

#[derive(Debug, PartialEq)]
pub struct FnDecl<'ast> {
    pub span: Span,
    pub name: Ident,
    pub params: Vec<'ast, Ident>,
    pub body: Block<'ast>,
}

#[derive(Debug, PartialEq)]
pub struct IfStmt<'ast> {
    pub span: Span,
    pub cond: Expr<'ast>,
    pub body: Block<'ast>,
    pub else_part: Option<&'ast ElsePart<'ast>>,
}

#[derive(Debug, PartialEq)]
pub enum ElsePart<'ast> {
    Else(Block<'ast>, Span),
    ElseIf(IfStmt<'ast>, Span),
}

impl ElsePart<'_> {
    pub fn span(&self) -> Span {
        match self {
            ElsePart::Else(_, span) => *span,
            ElsePart::ElseIf(_, span) => *span,
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct WhileStmt<'ast> {
    pub span: Span,
    pub cond: Expr<'ast>,
    pub body: Block<'ast>,
}

#[derive(Debug, PartialEq)]
pub enum Expr<'ast> {
    Ident(Ident),
    Literal(Literal<'ast>),
    UnaryOp(&'ast UnaryOp<'ast>),
    BinaryOp(&'ast BinaryOp<'ast>),
    Call(&'ast Call<'ast>),
}

impl Expr<'_> {
    pub fn span(&self) -> Span {
        match self {
            Expr::Literal(lit) => lit.span(),
            Expr::UnaryOp(unary) => unary.span,
            Expr::BinaryOp(binary) => binary.span,
            Expr::Ident(Ident { span, .. }) => *span,
            Expr::Call(call) => call.span,
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum Literal<'ast> {
    String(String, Span),
    Number(f64, Span),
    Array(Vec<'ast, Expr<'ast>>, Span),
    Object(Span),
    Boolean(bool, Span),
    Null(Span),
}

impl Literal<'_> {
    pub fn span(&self) -> Span {
        match self {
            Literal::String(_, span) => *span,
            Literal::Number(_, span) => *span,
            Literal::Array(_, span) => *span,
            Literal::Object(span) => *span,
            Literal::Boolean(_, span) => *span,
            Literal::Null(span) => *span,
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct UnaryOp<'ast> {
    pub span: Span,
    pub expr: Expr<'ast>,
    pub kind: UnaryOpKind,
}

#[derive(Debug, PartialEq)]
pub enum UnaryOpKind {
    Not,
    Neg,
}

#[derive(Debug, PartialEq)]
pub struct BinaryOp<'ast> {
    pub span: Span,
    pub lhs: Expr<'ast>,
    pub rhs: Expr<'ast>,
    pub kind: BinaryOpKind,
}

#[derive(Debug, PartialEq)]
pub enum BinaryOpKind {
    And,
    Or,
    Equal,
    GreaterEqual,
    Greater,
    LessEqual,
    Less,
    NotEqual,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
}

#[derive(Debug, PartialEq)]
pub struct Call<'ast> {
    pub callee: Expr<'ast>,
    pub span: Span,
    pub kind: CallKind<'ast>,
}

#[derive(Debug, PartialEq)]
pub enum CallKind<'ast> {
    Field(Ident),
    Fn(Vec<'ast, Expr<'ast>>),
}
