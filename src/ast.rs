//!
//! The AST module contains all structs and enums for the abstract syntax tree generated by the parser
#![allow(dead_code)]

use crate::errors::Span;

/// imagine interning or something here
pub type Symbol = String;

#[derive(Debug, Clone, PartialEq)]
pub struct Program(pub Vec<Stmt>);

#[derive(Debug, Clone, PartialEq)]
pub struct Block {
    pub stmts: Vec<Stmt>,
    pub span: Span,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Stmt {
    Declaration(Declaration),
    Assignment(Assignment),
    FnDecl(FnDecl),
    If(IfStmt),
    Loop(Block, Span),
    While(WhileStmt),
    Break(Span),
    Return(Option<Expr>, Span),
    Block(Block),
    Expr(Expr),
}

impl Stmt {
    pub fn span(&self) -> Span {
        match self {
            Stmt::Declaration(decl) => decl.span,
            Stmt::Assignment(assign) => assign.span,
            Stmt::FnDecl(decl) => decl.span,
            Stmt::If(if_stmt) => if_stmt.span,
            Stmt::Loop(_, span) => *span,
            Stmt::While(while_stmt) => while_stmt.span,
            Stmt::Break(span) => *span,
            Stmt::Return(_, span) => *span,
            Stmt::Block(block) => block.span,
            Stmt::Expr(expr) => expr.span(),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct Declaration {
    pub span: Span,
    name: Symbol,
    init: Expr,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Assignment {
    pub span: Span,
    pub lhs: Symbol,
    pub rhs: Expr,
}

#[derive(Debug, Clone, PartialEq)]
pub struct FnDecl {
    pub span: Span,
    pub name: Symbol,
    pub params: Vec<Symbol>,
    pub body: Block,
}

#[derive(Debug, Clone, PartialEq)]
pub struct IfStmt {
    pub span: Span,
    pub cond: Expr,
    pub body: Block,
    pub else_part: Option<Box<ElsePart>>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ElsePart {
    Else(Block, Span),
    ElseIf(IfStmt, Span),
}

impl ElsePart {
    pub fn span(&self) -> Span {
        match self {
            ElsePart::Else(_, span) => *span,
            ElsePart::ElseIf(_, span) => *span,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct WhileStmt {
    pub span: Span,
    pub cond: Expr,
    pub body: Block,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    Ident(Symbol, Span),
    Literal(Literal),
    UnaryOp(Box<UnaryOp>),
    BinaryOp(Box<BinaryOp>),
}

impl Expr {
    pub fn span(&self) -> Span {
        match self {
            Expr::Literal(lit) => lit.span(),
            Expr::UnaryOp(unary) => unary.span,
            Expr::BinaryOp(binary) => binary.span,
            Expr::Ident(_, span) => *span,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Literal {
    String(String, Span),
    Number(f64, Span),
    Array(Vec<Expr>, Span),
    Object(Span),
    Boolean(bool, Span),
    Null(Span),
}

impl Literal {
    pub fn span(&self) -> Span {
        match self {
            Literal::String(_, span) => *span,
            Literal::Number(_, span) => *span,
            Literal::Array(_, span) => *span,
            Literal::Object(span) => *span,
            Literal::Boolean(_, span) => *span,
            Literal::Null(span) => *span,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct UnaryOp {
    pub span: Span,
    pub expr: Expr,
    pub kind: UnaryOpKind,
}

#[derive(Debug, Clone, PartialEq)]
pub enum UnaryOpKind {
    Not,
    Neg,
}

#[derive(Debug, Clone, PartialEq)]
pub struct BinaryOp {
    pub span: Span,
    pub lhs: Expr,
    pub rhs: Expr,
    pub kind: BinaryOpKind,
}

#[derive(Debug, Clone, PartialEq)]
pub enum BinaryOpKind {
    And,
    Or,
    Equal,
    GreaterEqual,
    Greater,
    LessEqual,
    Less,
    NotEqual,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
}
