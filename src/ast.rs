//!
//! The AST module contains all structs and enums for the abstract syntax tree generated by the parser
#![allow(dead_code)]

use crate::errors::Span;

/// imagine interning or something here
pub type Symbol = String;

#[derive(Debug, Clone, PartialEq)]
pub struct Program(pub Block);

#[derive(Debug, Clone, PartialEq)]
pub struct Block(pub Vec<Stmt>);

#[derive(Debug, Clone, PartialEq)]
pub enum Stmt {
    Declaration(Declaration),
    Assignment(Assignment),
    FnDecl(FnDecl),
    If(IfStmt),
    Loop(Block),
    While(WhileStmt),
    Break(Break),
    Return(Option<Expr>),
    Expr(Expr),
}

#[derive(Debug, Clone, PartialEq)]
pub struct Declaration {
    pub span: Span,
    name: Symbol,
    init: Expr,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Assignment {
    pub span: Span,
    pub lhs: Symbol,
    pub rhs: Expr,
}

#[derive(Debug, Clone, PartialEq)]
pub struct FnDecl {
    pub span: Span,
    pub name: Symbol,
    pub params: Vec<Symbol>,
    pub body: Block,
}

#[derive(Debug, Clone, PartialEq)]
pub struct IfStmt {
    pub span: Span,
    pub condition: Expr,
    pub body: Block,
    pub else_part: Box<ElsePart>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ElsePart {
    Else(Block),
    ElseIf(IfStmt),
}

#[derive(Debug, Clone, PartialEq)]
pub struct WhileStmt {
    pub span: Span,
    pub cond: Expr,
    pub body: Block,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Break {
    pub span: Span,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    Literal(Literal),
    UnaryOp(Box<UnaryOp>),
    BinaryOp(Box<BinaryOp>),
}

impl Expr {
    pub fn span(&self) -> Span {
        match self {
            Expr::Literal(lit) => lit.span(),
            Expr::UnaryOp(unary) => unary.span,
            Expr::BinaryOp(binary) => binary.span,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Literal {
    String(String, Span),
    Number(f64, Span),
    Array(Vec<Expr>, Span),
    Object(Span),
    Boolean(bool, Span),
    Null(Span),
}

impl Literal {
    pub fn span(&self) -> Span {
        match self {
            Literal::String(_, span) => *span,
            Literal::Number(_, span) => *span,
            Literal::Array(_, span) => *span,
            Literal::Object(span) => *span,
            Literal::Boolean(_, span) => *span,
            Literal::Null(span) => *span,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct UnaryOp {
    pub span: Span,
    pub expr: Expr,
    pub kind: UnaryOpKind,
}

#[derive(Debug, Clone, PartialEq)]
pub enum UnaryOpKind {
    Not,
    Neg,
}

#[derive(Debug, Clone, PartialEq)]
pub struct BinaryOp {
    pub span: Span,
    pub lhs: Expr,
    pub rhs: Expr,
    pub kind: BinaryOpKind,
}

#[derive(Debug, Clone, PartialEq)]
pub enum BinaryOpKind {
    And,
    Or,
    Equal,
    GreaterEqual,
    Greater,
    LessEqual,
    Less,
    NotEqual,
    Add,
    Sub,
    Mul,
    Div,
    Mod,
}
